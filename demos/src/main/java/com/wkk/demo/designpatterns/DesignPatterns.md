## JAVA设计模式

### 设计模式的六大原则

总原则开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。
* 单一职责原则: 每个类应该实现单一的职责。
* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。
* 依赖倒转原则：要依赖于抽象,不要依赖于具体的实现，针对接口编程,不针对实现编程。
* 接口隔离原则：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分；
              使用多个隔离的接口,比使用单个接口好，建立最小的接口。
* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用(一个类对自己依赖的类知道的越少越好)，
            通过中间类建立联系。
* 合成复用原则：尽量使用合成(组合)/聚合,而不是使用继承。

## UML类图关系

[参考](http://www.uml.org.cn/oobject/201609062.asp)  
 (Unified Modeling Language)统一建模语言
 
 ### 类图简介
 
 ```text
泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），
组合(Composition)，依赖(Dependency)
泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖
```

1. 泛化（Generalization）

    属于一种继承关系；带三角箭头的实线，箭头指向父类

2. 实现（Realization）

    是一种类与接口的关系，表示类是接口所有特征和行为的实现;带三角箭头的虚线，箭头指向接口
    
3. 关联（Association)

    是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生  
    代码体现：成员变量  
    带普通箭头的实心线，指向被拥有者
   
4. 聚合（Aggregation）

    是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。  
    聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。  
    代码体现：成员变量  
    带空心菱形的实心线，菱形指向整体
   
5. 组合(Composition)   
    
    是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系  
    组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。  
    代码体现：成员变量    
    带实心菱形的实线，菱形指向整体
    
6. 依赖(Dependency)

    是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.  
    代码体现：局部变量、方法的参数或者对静态方法的调用  
    带箭头的虚线，指向被使用者
    
### 创建型

#### 1. 工厂方法模式（Factory Method） [参考](https://blog.csdn.net/u010425776/article/details/48153493)
    
```text
    通过工厂类的子类生产 产品类的实现，避免了后续新增产品类时，修改工厂类，只需要新增一个工厂类的子类来生产对应的产品
 通过客户端传入的指定值,通过工厂类创建产品对象
```
> 工厂模式和简单工厂模式的比较：
```text
    简单工厂模式把创建哪个运算类的对象放在工厂类中实现，也就是放在低层模块中实现；从而客户端在需要创建对象时仅仅需要给工厂传入
  一个key就能获取想要的对象。但当运算体系需要扩展的时候，就需要在工厂中增加新对象的判断，从而破坏了“封闭修改”的原则。
  工厂模式由于抽象出了一个工厂父类，并且每一运算子类都有一个专门创建该子类对象的工厂子类，因此在增加运算子类的时候，工厂类
  不需要修改任何代码，只需要增加一个工厂子类即可。但客户端就需要给判断究竟给工厂父类创建哪个工厂子类对象。
``` 

#### 2.抽象工厂模式 [参考](https://blog.csdn.net/u010425776/article/details/48180893)

> 抽象工厂模式和工厂模式的异同
```text
    两种模式本质上都是一样的，思想是一样的，抽象工厂模式只不过是工厂模式的一种扩展。
    工厂方法模式：
    一个抽象产品类，可以派生出多个具体产品类。   
    一个抽象工厂类，可以派生出多个具体工厂类。   
    每个具体工厂类只能创建一个具体产品类的实例。  
    抽象工厂模式：
    多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
    一个抽象工厂类，可以派生出多个具体工厂类。   
    每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。
    
```

#### 3.单例模式（Singleton）

        一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。
        它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间；
    能够避免由于操作多个实例导致的逻辑错误。如果一个对象有可能贯穿整个应用程序，而且起到了全局
    统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。
 
> 饿汉式 不存在线程安全问题，但是用到次数少会浪费空间

> 懒汉式 存在线程安全问题

> 懒汉式 + 加锁  线程安全 相对高效 会有一些问题？？！！

> 静态内部类(懒汉+无锁) 利用类加载机制
    
    根据java加载类的时机，只有当使用到的时候才会加载，类加载是线程互斥的(类只会被一个线程加载)，由此保证单例

上面提到的四种实现单例的方式都有共同的缺点：  
需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例。  
可以使用反射强行调用私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二
个实例的时候抛异常）。

> <font color="#006600">枚举</font>  枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，
还提供了自动序列化机制，防止反序列化的时候创建新的对象。

#### 4.建造者模式(Builder) [参考](https://blog.csdn.net/u010425776/article/details/48104143)

        对于一个业务分为具体好多步骤完成，可以把所有的步骤作为抽象函数写到接口Builder中，在实现类中重写所有的
      抽象函数，再将建造者对象传递给指挥者，让指挥者依次执行所有的步骤；通过Product的getProduct()，获取最后生成的对象。
  
  > 建造者模式的好处：
    
        将复杂业务场景，封装在一个个建造者中，隐藏步骤实现的复杂性，修改产品内部表示时，是需要换一个具体的建造者就可以了。  
      避免了客户程序在构建复杂对象时候的大量代码，使得客户程序变的简洁。

#### 5. 原型模式（Prototype）

        该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。
        一个原型类，只需要实现Cloneable接口，覆写clone方法
        浅拷贝：将对象中基本数据类型的值复制到新的对象中去，若对象中有引用类型的属性，则将引用复制给新对象，
      此时，新旧对象中引用类型的指针都指向同一个对象。
        深拷贝：深拷贝和浅拷贝对于基本数据类型都是一样复制，不同之处在于：浅拷贝之后新旧对象中的引用类型的变量都指向
      同一个对象，而深拷贝当遇到引用类型的对象时，再new一个对象，新对象中的引用类型变量指向新创建的对象
      
  ## 结构型模式(7种)
  
        适配器模式是各种模式的起源，装饰模式，代理模式，外观模式，桥接模式，组合模式，享元模式
        
  ### 6. 适配器模式
        
   将某个类的接口转换成客户端期望的另一种接口的形式，目的是消除由于接口不匹配所造成的类的兼容性问题。
   类适配器，对象适配器，接口适配器
   
> 类适配器

    继承要转换的类，实现客户端期望的接口，在客户端期望的接口方法中直接调用父类的方法就好
    
> 对象适配器

    实现客户端期望的接口，将要转换的类作为成员变量，在客户端期望的接口方法中直接调用成员变量的方法就好
    
> 接口适配器

    接口定义的抽象方法，子类不用全部实现只要实现一部分就好，使用一个中间抽象类实现接口的方法，子类实现中间类
    只要重写所需方法就好了
    
### 7. 装饰模式（Decorator）

在运行的过程中，给一个对象动态地添加一些额外的行为。每一个具体的装饰类都为被装饰类添加一个功能

    1. 装饰类实现与被装饰类的接口
    2. 被装饰类作为装饰类的成员变量
    3. 装饰类实现与被装饰类一致的方法，方法内部自定义自己要装饰的代码，并调用被装饰类的方法
    
> 装饰模式和建造者模式的异同？
  
  相同点：建造者模式和装饰模式都使用了面向切面编程的思想，装饰模式中的装饰类和建造者模式中建造者类的一个个函数都是为被装饰对象附加函数额外功能或为对象中的属性赋值。
  
  不同点：建造者给对象添砖加瓦的顺序是固定的，在Director类中写好的；
  
  而装饰模式中需要添加哪些操作是由客户端决定的。动态的为一个对象增加功能，而且还能动态撤销。
 
### 8.代理模式（Proxy）     

调用一个类时，不直接调用，通过这个类的代理类调用
代理类和被代理类需要实现同一个接口，这样他们有共同的函数。函数真正的实现在被代理类中完成，代理类的每一个函数仅仅是调用了被代理类的对应的函数。
       
> 代理模式的应用：
  
  1.远程代理。也就是为一个对象在不同地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
  
  2.虚拟代理。当需要创建的对象开销很大时，通过代理对象存放需要很长时间实例化的真正对象。
  
  比如：打开一个有很多图片的HTML页面，它很快就会被打开，但一开始里面只有文字，图片只看到框而没有图片，要过一会儿后图片才会被加载。这里图片的框就是一个代理对象。
  
  3.安全代理。用来控制真实对象访问时的权限。
  
  4.智能指引。当调用真实对象前，代理处理另外一些事情。也就是在访问原本对象之前，再附加一些业务处理
  
### 9.外观模式（Facade）

  解决类之间的依赖关系,降低了类类之间的耦合度,类似spring
  现在有好多个子系统，他们都有对外的接口，如果让客户端直接与这些子系统交互，那么客户端代码会过于复杂；这时候引入一个外观类，用于处理与各
  个子系统之间的交互，客户端只需调用外观类简单的接口即可操作各个子系统。
> 外观模式的官方定义：  
  
  为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
  
### 10.桥接模式（Bridge）

桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化；
将原本两个继承体系使用聚合/组合连接在一起---桥接模式 

> 继承的缺点：

由于对象的继承关系是在编译时就定义好了，因此无法在运行时改变子类中从父类继承过来的实现。

并且子类的实现与父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类变化的发生。

当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。

这种依赖关系限制了灵活性，并最终限制了复用性。

> 什么是“合成/聚合复用原则”？

在程序设计时，应尽量使用合成/聚合，而尽量避免使用继承

### 11.组合模式（Composite）

组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便

### 12.享元模式（Flyweight）

享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。

> 享元模式的优点：
  
  享元模式通过共享对象的方式，把所有对象的公共属性存放在同一个对象中，不同的属性存放在外部类中，从而起到了节省存储空间的作用。
  
## 关系模式/行为型模式

  第一类：通过父类与子类的关系进行实现 ： 策略模式，模板方法模式
  第二类：两个类之间： 观察者模式，迭代器模式，责任链模式，命令模式
  第三类：类的状态： 状态模式，备忘录模式
  第四类：通过中间类： 访问者模式，中介者模式，解释器模式
  
### 13.策略模式
    
  [参考](https://blog.csdn.net/u010425776/article/details/48130617)

    对于同一种行为，选择方式不同处理不同，每一种选择就是一种策略,例如：超市打折，不同打折方式处理不同，通过  
    客户端的选择做出对应处理
    
    优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。
    缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。
 
### 14.模板方法模式

    一个抽象类中，有一个主方法，再定义1...n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，
    重写抽象方法，通过调用抽象类，实现对子类的调用
    
    优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。
    缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

### 15.观察者模式

    当一个对象发生变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系
    
    优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。
    缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 
          2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有
            相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
            

### 16.迭代器模式 （Iterator）

    通过迭代器对象 顺序访问集合对象的元素，不需要知道集合对象的底层表示
    
    优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 
          4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。
    缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，
         类的个数成对增加，这在一定程度上增加了系统的复杂性。
         
### 17. 责任链模式 （Chain of Responsibility）

    为请求创建了一个接收者对象的链，每个接收者都有下一个接收者对象的引用，使得每个接收者都可能处理请求  
    对请求发送者与接收者解耦 --JS 中的事件冒泡
    
    优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 
        3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。
    缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 
         3、可能不容易观察运行时的特征，有碍于除错。
  
### 18.命令模式（Command）

    命令发出者不需要直接调用命令执行者，通过一个中间类根据命令不同调用命令执行者，命令发出者与  
    命令执行者解耦
    优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。
    缺点：使用命令模式可能会导致某些系统有过多的具体命令类。
   
   
### 19.备忘录模式（Memento）
    
    保存一个对象的某个状态，以便在适当的时候恢复对象
    
    使用场景： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。
    注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。
    
### 20. 状态模式（State）

    类的行为是基于它的状态改变的,当对象的状态改变时，同时改变其行为
    
    优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。
    缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。
    使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。
    注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。

### 21. 访问者模式（Visitor）
[参考](http://www.runoob.com/design-pattern/visitor-pattern.html)
    
    访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果  
    由访问者决定怎么操作获取的数据
    
    优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。
    缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。
    
### 22、中介者模式（Mediator）

    用来降低多个对象和类之间的通信复杂性和耦合性，通过一个中介类处理对象依赖关系
    
    优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。
    缺点：中介者会庞大，变得复杂难以维护。
    
### 23、解释器模式（Interpreter）

    一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄
    优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。
    缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。